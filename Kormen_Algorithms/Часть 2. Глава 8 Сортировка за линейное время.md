### Опорный конспект "Глава 8. Сортировка за линейное время"

Глава 8 книги "Алгоритмы: построение и анализ" охватывает алгоритмы сортировки, которые могут достигать линейной временной сложности, такие как сортировка подсчетом, сортировка слиянием и пирамидальная сортировка. Эти алгоритмы применимы в специфических условиях, когда известен диапазон значений элементов.

---

### Основные алгоритмы сортировки за линейное время

1. **Сортировка подсчетом (Counting Sort)**:
   - Подходит для сортировки целых чисел в заданном диапазоне.
   - Работает за линейное время \( O(n + k) \), где \( n \) — количество элементов, а \( k \) — диапазон значений.

   **Процесс**:
   - Создание массива подсчета для хранения количества вхождений каждого значения.
   - Накопление данных в массиве подсчета.
   - Перенос значений из массива подсчета обратно в исходный массив в отсортированном порядке.

   **Трудные места**:
   - Понимание, как правильно определить диапазон \( k \). Если диапазон значительно больше, чем \( n \), эффективность теряется.
   - Ошибки при индексировании могут привести к неправильной сортировке.

2. **Сортировка по радиусам (Radix Sort)**:
   - Работает на числах с фиксированной длиной, сортируя их по разрядам.
   - Использует стабилизирующую сортировку (например, сортировку подсчетом) для сортировки по каждому разряду.

   **Процесс**:
   - Сортировка чисел по каждому разряду начиная с младших до старших.
   - Для каждого разряда используется стабильный алгоритм сортировки.

   **Временная сложность**:
   - При длине числа \( d \) и \( n \) элементах: \( O(n \cdot d) \).
   - Это может считаться линейным, если \( d \) является постоянной.

   **Трудные места**:
   - Необходимость понимания, как работать с разрядами и как реализовать стабилизирующую сортировку для каждого разряда.

3. **Сортировка по битам (Bucket Sort)**:
   - Элементы разбиваются на "ведра", и каждый бакет сортируется отдельно (обычно с помощью другой сортировки).

   **Процесс**:
   - Распределение элементов по ведрам на основе их значений.
   - Сортировка каждого ведра (обычно с помощью другой сортировки).
   - Слияние всех ведер в один отсортированный массив.

   **Временная сложность**:
   - В среднем: \( O(n + k) \), где \( k \) — количество ведер.

   **Трудные места**:
   - Определение правильного количества ведер и распределение элементов между ними. Если ведер слишком мало или много, это повлияет на производительность.

### Сравнение алгоритмов

- **Сортировка подсчетом**:
  - Эффективна для небольших диапазонов целых чисел.
  - Не подходит для данных с большими диапазонами.

- **Сортировка по радиусам**:
  - Подходит для чисел с фиксированной длиной, особенно когда \( d \) мал.
  - Использует другие алгоритмы для каждой итерации.

- **Сортировка по битам**:
  - Полезна, когда данные распределены равномерно по диапазону.
  - Неэффективна для сильно несбалансированных наборов данных.

### Нюансы и трудные места

1. **Понимание ограничений**:
   - Все три алгоритма работают эффективно только при определенных условиях (например, известный диапазон, фиксированная длина числа). Если данные не соответствуют этим условиям, алгоритмы могут оказаться неэффективными.

2. **Правильное индексирование**:
   - Ошибки в индексировании массива подсчета или ведер могут привести к неправильным результатам. Важно быть внимательным при работе с индексами.

3. **Выбор алгоритма**:
   - Важно знать, когда применять каждый из алгоритмов, в зависимости от характера входных данных и их диапазона. 

### Заключение

Глава 8 предоставляет глубокое понимание алгоритмов сортировки, которые могут достигать линейной временной сложности. Эти алгоритмы полезны в специфических контекстах и требуют внимательного подхода к реализации. Практика и реализация каждого из алгоритмов помогут закрепить материал и развить навыки работы с сортировкой за линейное время.